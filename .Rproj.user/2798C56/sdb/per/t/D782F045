{
    "contents" : "# Variable Transformations\n# Libraries\nlibrary(doBy)\nlibrary(ggplot2)\n\n# Read in data from GitHub\norders.train <- read.table(\"orders_train.txt\", header = TRUE, sep = \";\")\nstr(orders.train)\n\n#-----------------------#\n# Correct Data Formats  #\n#-----------------------#\n\n# Update date fields to date type instead of factors\norders.train$orderDate <- as.Date(orders.train$orderDate, format = \"%Y-%m-%d\")\norders.train$deliveryDate <- as.Date(orders.train$deliveryDate, format = \"%Y-%m-%d\")\norders.train$dateOfBirth <- as.Date(orders.train$dateOfBirth, format = \"%Y-%m-%d\")\norders.train$creationDate <- as.Date(orders.train$creationDate, format = \"%Y-%m-%d\")\n\n\n#--------------------#\n# QA Report Output   #\n#--------------------#\n\n# Summary data for the QA report\nsummary(orders.train$orderDate)\nsummary(orders.train$deliveryDate)\nsummary(orders.train$creationDate)\nsummary(orders.train$dateOfBirth)\n\n# Export top and bottom 10 cases for QA report\nprint(orders.train[1:10,])\nprint(orders.train[481083:481092,])\n\n# Export frequency tables for categorical variables (not IDs)\ntable(orders.train$size)\ntable(orders.train$color)\ntable(orders.train$salutation)\ntable(orders.train$state)\ntable(orders.train$returnShipment)\n# Bar plots\n# Need to update options to fit labels \npar(las=2) # make label text perpendicular to axis\noptions(scipen=50,digits=5) # change default setting for when R converts to using sci notation\nbarplot(table(orders.train$size), main=\"Size Distribution\", horiz=TRUE, cex.names=0.5)\npar(mar=c(4,6,4,2)) # increase y-axis margin (order is bottom,left,top,right)\nbarplot(table(orders.train$color), main=\"Color Distribution\", horiz=TRUE, cex.names=0.6)\nbarplot(table(orders.train$salutation), main=\"Salutation Distribution\", horiz=TRUE)\npar(mar=c(4,10,4,2)) # increase y-axis margin (order is bottom,left,top,right)\nbarplot(table(orders.train$state), main=\"State Distribution\", horiz=TRUE, cex.names=0.6)\n\n#-----------------------#\n# End QA Report output  #\n#-----------------------#\n\n#---------------#\n# Data Checks   #\n#---------------#\n\n# Check that orderItemID is a uniqueID (may need to map to it later)\n  # Since it looks like it's just the record number, it should match the row number\n  # Printing cases where it's not- this should return 0 records\norders.train[-which(orders.train$orderItemID!=orders.train$row.names),]\n# Check that each itemID is associated with just one manufacturerID\n  # Create a table by item ID with the min & max of manufacturer ID\nitem.check <- summaryBy(manufacturerID ~ itemID, orders.train, FUN=c(min,max))\n  # then check that there are no cases where the min and max are different\nitem.check[-which(item.check$manufacturerID.min==item.check$manufacturerID.max),]\n  # get full details on these itemIDs\nView(orders.train[which(orders.train$itemID==c(1627,1682,1696,2252)),])\n  #### How do we want to handle these??\n  # This affects 145 observations\n  # It's not undheard of for two manufacturers to make the same item, \n  # but there are clearly errors as the items from the different manufacturers\n  # are sometime not even in the same size range\n  # There are not many and return frequency is not far off\n  # we could double check with a t-test or a binomial test on missing obs and compare to the confidence interval\nbinom.test(73, 145, p = .4824, alternative = c(\"two.sided\"), conf.level = 0.95)\n  # x= number of 'successes',n=number of trials, p = hypothesized prob of success, or that of return rate of our population\n  # http://stat.ethz.ch/R-manual/R-patched/library/stats/html/binom.test.html\n  # Since true prob is in confidence interval, there is no bias and I concur to remove these obs.  JB.  \nremove(item.check)\n\n# Customer checks- salutation, state, bday, and creation date should match across records\n# Steps similar to item check above\ncust.check <- summaryBy(salutation + state + dateOfBirth + creationDate ~ customerID, orders.train, FUN=c(min,max))\ncust.check[-which(cust.check$salutation.min==cust.check$salutation.max),] # 0 records\ncust.check[-which(cust.check$state.min==cust.check$state.max),] # 0 records\ncust.check[-which(cust.check$dateOfBirth.min==cust.check$dateOfBirth.max),] # large number of records, viewing the table instead\nView(cust.check[-which(cust.check$dateOfBirth.min==cust.check$dateOfBirth.max),]) # looks like they're all NAs, which are ok\ncust.check[-which(cust.check$creationDate.min==cust.check$creationDate.max),] # 0 records\nremove(cust.check)\n\n#--------------------------#\n# Variable Transformations #\n#     And Data Cleaning    #\n#--------------------------#\n\n# Add date diff variables\n# Time from when order was placed to delivery, in days\norders.train$timeToDeliver <- as.numeric(difftime(orders.train$deliveryDate,orders.train$orderDate,unit=\"days\"))\n# Age of the account, in years but rounded to nearest tenth- seemed like a continuous variable was overkill here\norders.train$accountAge <- round(as.numeric(difftime(orders.train$orderDate,orders.train$creationDate,unit=\"weeks\"))/52.25,1)\n# want customer's age as an integer, similar to when you ask how old someone is\norders.train$customerAge <- floor(as.numeric(difftime(orders.train$orderDate,orders.train$dateOfBirth,unit=\"weeks\"))/52.25)\n# Check\nsummary(orders.train[15:17])\n# timeToDeliver should never be negative, and age should never be negative\norders.train$timeToDeliver <- ifelse(orders.train$timeToDeliver<0,NA,orders.train$timeToDeliver)\norders.train$customerAge <- ifelse(orders.train$customerAge<0,NA,orders.train$customerAge)\n# age should also probably not be > 100 - what should we use for the cut-off?\norders.train$customerAge <- ifelse(orders.train$customerAge>100,NA,orders.train$customerAge)\n# Recheck\nsummary(orders.train[15:17])\n\n# Recode ? to NA for color\norders.train$color <- ifelse(orders.train$color==\"?\",NA,orders.train$color)\n# Recode \"not reported\" to NA for salutation\norders.train$salutation <- ifelse(orders.train$salutation==\"not reported\",NA,orders.train$salutation)\n\n# Sizing recodes - creating a table with frequencies to work from and going to remove sizes as I recode them\n# There may be some errors here- for example, Euro children's sizes start at 50, but some conversions go up to size 52 for men's suits, etc\n##### not sure how many items this affects, but we could check the range of values for those items to see which class they belong to?\nsize.table <- summaryBy(size ~ size,orders.train,FUN=length)\nView(size.table)\n\n# Ones that seem like US sizes\norders.train$sizeLetter <- ifelse(as.character(orders.train$size)>\"a\",toupper(as.character(orders.train$size)),NA)\nsize.table <- size.table[-which(as.character(size.table$size)>\"a\"),]\norders.train$sizePant <- ifelse(as.numeric(as.character(orders.train$size))>2900,as.numeric(as.character(orders.train$size)),NA)\nsize.table <- size.table[-which(as.numeric(as.character(size.table$size))>2900),]\n\n# Euro children's sizes go from 50-188\n# http://www.ebay.com/gds/Guide-to-Understanding-European-Clothing-Sizes-/10000000007740616/g.html\norders.train$sizeChild <- ifelse(as.numeric(as.character(orders.train$size))>=50 & as.numeric(as.character(orders.train$size))<=188,as.numeric(as.character(orders.train$size)),NA)\nsize.table <- size.table[-which(as.numeric(as.character(size.table$size))>=50 & as.numeric(as.character(size.table$size))<=188),]\n\n#  Maybe sizes < 20 are US type sizes - either for shoes or women's dresses \n#  both are difficult to size without trying on\norders.train$sizeShoeDress <- ifelse(as.numeric(as.character(orders.train$size))>=1 & as.numeric(as.character(orders.train$size))<=20,as.numeric(as.character(orders.train$size)),NA)\nsize.table <- size.table[-which(as.numeric(as.character(size.table$size))>=1 & as.numeric(as.character(size.table$size))<=20),]\n\n#-------------------------------#\n# CAN'T GET CODE TO WORK HERE#\n# Plus sizes different in Shoe / Dress size range?\n#orders.train$sizePlus <- ifelse(as.character(orders.train$size)=='2+' & as.character(orders.train$size)=='3+' & as.character(orders.train$size)=='4+' & as.character(orders.train$size)=='5+' \n#                                & as.character(orders.train$size)=='6+' & as.character(orders.train$size)=='7+' & as.character(orders.train$size)=='8+' & as.character(orders.train$size)=='9+' \n#                                & as.character(orders.train$size)=='10+' & as.character(orders.train$size)=='11+' & as.character(orders.train$size)=='12+' & as.character(orders.train$size)=='13+',\n#                                as.character(orders.train$size), NA)\n#size.table <- size.table[-which(as.character(orders.train$size)=='2+' & as.character(orders.train$size)=='3+' & as.character(orders.train$size)=='4+' & as.character(orders.train$size)=='5+' \n#                                & as.character(orders.train$size)=='6+' & as.character(orders.train$size)=='7+' & as.character(orders.train$size)=='8+' & as.character(orders.train$size)=='9+' \n#                                & as.character(orders.train$size)=='10+' & as.character(orders.train$size)=='11+' & as.character(orders.train$size)=='12+' & as.character(orders.train$size)=='13+'),]\n\n\n#orders.train$sizePlus <- ifelse(as.numeric(as.character(orders.train$size))=='2+' & as.numeric(as.character(orders.train$size))=='3+' & as.numeric(as.character(orders.train$size))=='4+' & as.numeric(as.character(orders.train$size))=='5+' \n#                                & as.numeric(as.character(orders.train$size))=='6+' & as.numeric(as.character(orders.train$size))=='7+' & as.numeric(as.character(orders.train$size))=='8+' & as.numeric(as.character(orders.train$size))=='9+' \n#                                & as.numeric(as.character(orders.train$size))=='10+' & as.numeric(as.character(orders.train$size))=='11+' & as.numeric(as.character(orders.train$size))=='12+' & as.numeric(as.character(orders.train$size))=='13+',\n#                                as.numeric(as.character(orders.train$size)), NA)\n#size.table <- size.table[-which(as.character(orders.train$size)=='2+' & as.character(orders.train$size)=='3+' & as.character(orders.train$size)=='4+' & as.character(orders.train$size)=='5+' \n#                                & as.character(orders.train$size)=='6+' & as.character(orders.train$size)=='7+' & as.character(orders.train$size)=='8+' & as.character(orders.train$size)=='9+' \n#                                & as.character(orders.train$size)=='10+' & as.character(orders.train$size)=='11+' & as.character(orders.train$size)=='12+' & as.character(orders.train$size)=='13+'),]\n#-------------------------------#\n\n# Remaining\norders.train$sizeOther <- ifelse(is.na(orders.train$sizeLetter) & is.na(orders.train$sizePant) & is.na(orders.train$sizeChild) & is.na(orders.train$sizeShoeDress), as.character(orders.train$size),NA)\n\n# check\ntable(orders.train$sizeLetter)\ntable(orders.train$sizePant)\ntable(orders.train$sizeChild)\ntable(orders.train$sizeShoeDress)\ntable(orders.train$sizeOther)\n#table(orders.train$sizePlus)\n\n# Identification Markers for various clothing type\norders.train$LetterSize <- ifelse(is.na(orders.train$sizeLetter),0,1)\norders.train$Pants <- ifelse(is.na(orders.train$sizePant),0,1)\norders.train$ChildSize <- ifelse(is.na(orders.train$sizeChild),0,1)\norders.train$ShoeDress <- ifelse(is.na(orders.train$sizeShoeDress),0,1)\n#orders.train$PlusSize <- ifelse(is.na(orders.train$sizePlus),0,1)\n\n\n\n##### Euro Women's Dress sizes seem to range between 28 and 54 - maybe we leave these alone and in 'other'\n#  https://www.google.com/search?q=dress+sizes&tbm=isch&tbo=u&source=univ&sa=X&ei=giRfU_LmMKa6yQGu4IHwDw&ved=0CCgQsAQ&biw=1080&bih=484#q=european+dress+sizes&tbm=isch&facrc=_&imgrc=VvapZ5APyTOnrM%253A%3B-WKQ1Hty0kzBiM%3Bhttp%253A%252F%252Fwww.europeword.com%252Fblog%252Fwp-content%252Fuploads%252Feuropean-dress-sizes.jpg%3Bhttp%253A%252F%252Fwww.europeword.com%252Fblog%252Feurope%252Feuropean-dress-sizes%252F%3B756%3B479\n#  Tried to look up men's shirt sizes too, but there is a lot of overlap in the systems here\n#####\n#### DO WE NEED TO ADD PLUS SIZES HERE??? ######\n\n\n\n####### END SIZING #########\n\n# Densities for all numeric (non-ID)\nggplot(orders.train,aes(x=price)) + geom_density(fill=\"grey\") + ggtitle(\"Price Distribution\")\nggplot(orders.train,aes(x=timeToDeliver)) + geom_density(fill=\"grey\") + ggtitle(\"Delivery Time Distribution\")\nggplot(orders.train,aes(x=customerAge)) + geom_density(fill=\"grey\") + ggtitle(\"Age Distribution\")\nggplot(orders.train,aes(x=accountAge)) + geom_density(fill=\"grey\") + ggtitle(\"Account Age Distribution\")\n\n\n\n# Add mode function - note that this only gives one mode if there is more than one\nmymode <- function(x){\n  names(sort(-table(as.character(x))))[1]\n}\ncustMode1 <- summaryBy(toupper(as.character(orders.train$size)) ~ orders.train$customerID, orders.train, FUN=mymode)\ncustMode2 <- summaryBy(sizeLetter ~ customerID, orders.train[-which(is.na(orders.train$sizeLetter)),], FUN=mymode)\ncustMode3 <- summaryBy(sizePant ~ customerID, orders.train[-which(is.na(orders.train$sizePant)),], FUN=mymode)\ncustMode4 <- summaryBy(sizeChild ~ customerID, orders.train[-which(is.na(orders.train$sizeChild)),], FUN=mymode)\ncustMode5 <- summaryBy(sizeOther ~ customerID, orders.train[-which(is.na(orders.train$sizeOther)),], FUN=mymode)\ncustMode6 <- summaryBy(sizeShoeDress ~ customerID, orders.train[-which(is.na(orders.train$sizeShoeDress)),], FUN=mymode)\ncustMode <- merge(custMode1,custMode2,by=\"customerID\",all=T)\ncustMode <- merge(custMode,custMode3,by=\"customerID\",all=T)\ncustMode <- merge(custMode,custMode4,by=\"customerID\",all=T)\ncustMode <- merge(custMode,custMode5,by=\"customerID\",all=T)\ncustMode <- merge(custMode,custMode6,by=\"customerID\",all=T)\nnames(custMode) <- c(\"customerID\",\"sizeMode\",\"szLetterMode\",\"szPantMode\", \"szChildMode\", \"szOtherMode\", \"szShoeDressMode\")\n# Merge back into original file, then drop the unnecessary data frames to clean up the workspace\n##### Should we be looking at mode for each clothing type, and just noting if the next order does not belong to that mode for that type,\n##### or is this just getting too complicated?\norders.train <- merge(orders.train,custMode,by=\"customerID\",all=T)\nremove(custMode,custMode1,custMode2,custMode3,custMode4,custMode5,size.table)\n\n# Add holiday/bday flags\n# NOTE: ALL OBS ARE MARKED '1' FOR BDAY\norders.train$holidayFlag <- ifelse(as.character(orders.train$orderDate,format=\"%m%d\")>=\"1125\" &\n  as.character(orders.train$orderDate,format=\"%m%d\")<=\"1230\",1,0)\norders.train$bdayFlag <- ifelse(as.character(orders.train$orderDate,format=\"%m%d\")>=as.character(orders.train$dateOfBirth-30,format=\"%m%d\") & \n  as.character(orders.train$orderDate,format=\"%m%d\")<=as.character(orders.train$dateOfBirth+5,format=\"%m%d\"),1,0)\n# Need to address cases at the beginning/end of the year\n# Get count of bdayFlags for comparison in next step\nsummaryBy(bdayFlag ~ 1, orders.train, FUN=sum, na.rm=T)\n# Bdays after 12/26 or before 1/31 - the order date can be until the end of the year and part of the next\norders.train$bdayFlag <- ifelse((as.character(orders.train$dateOfBirth,format=\"%m%d\")>\"1226\"|as.character(orders.train$dateOfBirth,format=\"%m%d\")<=\"0130\") & \n  (as.character(orders.train$orderDate,format=\"%m%d\")>=as.character(orders.train$dateOfBirth-30,format=\"%m%d\") | as.numeric(as.character(orders.train$orderDate,format=\"%m%d\"))<=as.numeric(as.character(orders.train$dateOfBirth+5,format=\"%m%d\"))),1,orders.train$bdayFlag)\nsummaryBy(bdayFlag ~ 1, orders.train, FUN=sum, na.rm=T)\n# Visually check some of these - appears to be working correctly\nView(orders.train[which(orders.train$bdayFlag==1 & (as.character(orders.train$orderDate,format=\"%m%d\")<\"0104\" | as.character(orders.train$orderDate,format=\"%m%d\")>\"1215\")),])\n\n# Add number of items per order\nnumItems <- summaryBy(orderItemID ~ customerID + orderDate, orders.train, FUN=length)\nnames(numItems) <- c(\"customerID\",\"orderDate\",\"numItemsInOrder\")\norders.train <- merge(orders.train,numItems,by=c(\"customerID\",\"orderDate\"))\n# Add num items with that items ID per order\n# Also looking at number of returns since we expect higher returns if they order dups\ndupItems <- summaryBy(returnShipment ~ customerID + orderDate + itemID, orders.train, FUN=c(length,sum))\nnames(dupItems) <- c(\"customerID\",\"orderDate\",\"itemID\",\"numItemID\",\"numItemIDReturned\")\n# Check hypothesis\nsummaryBy(numItemIDReturned ~ numItemID, dupItems, FUN=c(length,median,mean))\n# Leaving out number returned when merging back in because we don't want to accidentally include as a predictor\norders.train <- merge(orders.train,dupItems[1:4],by=c(\"customerID\",\"orderDate\",\"itemID\"))\n# Dropping unnecessary data frames\nremove(numItems,dupItems)\n\n# Find high risk manufacturers/items/customers\n# Do we want to only include ones that had a certain number of items ordered? \n# I picked 50 as a cutoff, but that's arbitrary; could use median or a percentile\n    # Manufacturers\nriskyManuf <- summaryBy(returnShipment ~ manufacturerID,orders.train,FUN=c(length,mean))\nsummary(riskyManuf$returnShipment.mean)\nsummary(riskyManuf$returnShipment.length)\nsummary(riskyManuf[which(riskyManuf$returnShipment.length>=50),]$returnShipment.mean)\n# Using top quartile for a risk cutoff\nriskyManuf$manufRiskFlag <- ifelse(riskyManuf$returnShipment.length>=50 & riskyManuf$returnShipment.mean >=0.5573,1,0)\nnames(riskyManuf) <- c(\"manufacturerID\",\"numManufOrders\",\"numManufReturns\",\"manufRiskFlag\")\n# Merge\norders.train <- merge(orders.train,riskyManuf,by=\"manufacturerID\")\n    # Items\nriskyItems <- summaryBy(returnShipment ~ itemID,orders.train,FUN=c(length,mean))\nsummary(riskyItems$returnShipment.mean)\nsummary(riskyItems$returnShipment.length)\nsummary(riskyItems[which(riskyItems$returnShipment.length>=50),]$returnShipment.mean)\n# Using top quartile for a risk cutoff\nriskyItems$itemRiskFlag <- ifelse(riskyItems$returnShipment.length>=50 & riskyItems$returnShipment.mean >=0.5938,1,0)\nnames(riskyItems) <- c(\"itemID\",\"numItemOrders\",\"numItemReturns\",\"itemRiskFlag\")\n# Merge\norders.train <- merge(orders.train,riskyItems,by=\"itemID\")\n    # Customers\nriskyCust <- summaryBy(returnShipment ~ customerID,orders.train,FUN=c(length,mean))\nsummary(riskyCust$returnShipment.mean)\nsummary(riskyCust$returnShipment.length)\nsummary(riskyCust[which(riskyCust$returnShipment.length>=50),]$returnShipment.mean)\n# Using top quartile for a risk cutoff\nriskyCust$custRiskFlag <- ifelse(riskyCust$returnShipment.length>=50 & riskyCust$returnShipment.mean >=0.6667,1,0)\nnames(riskyCust) <- c(\"customerID\",\"numCustOrders\",\"numCustReturns\",\"custRiskFlag\")\n# Merge & clear workspace\norders.train <- merge(orders.train,riskyCust,by=\"customerID\")\nremove(riskyManuf,riskyItems,riskyCust)\n\n# Check if items are always the same price (expect they're not, but wanted to verify before coding more)\n# Using a merge because if I try to do quantile and mean in 1 step, the labels aren't clear\nitemPricing <- merge(summaryBy(price ~ itemID,orders.train,FUN=quantile),\n    summaryBy(price ~ itemID,orders.train,FUN=mean),by=\"itemID\")\nView(itemPricing) # confirmed, going to attach to the orders.train data frame so we can later flag \norders.train <- merge(orders.train, itemPricing, by=\"itemID\")\norders.train$difFromMeanPrice = orders.train$price - orders.train$price.mean\nremove(itemPricing)\n# Look at mean of returnShipment for each price point\n# Currently saving this out as a separate table because I'm not entirely sure what to do with it\nreturnsByPrice <- summaryBy(returnShipment ~ itemID + price, orders.train, FUN=c(length,mean))\n\n# Create OrderID variable\norders.table <- summaryBy(returnShipment ~ orderDate + customerID, orders.train, FUN=mean)\norders.table$orderID <- 1:nrow(orders.table)\norders.table <- orders.table[,-3]\norders.train <- merge(orders.train,orders.table,by=c(\"customerID\",\"orderDate\"))\nremove(orders.table)\n\n\nstr(orders.train)\n\n# -------------------------------------------- #\n# Ideas for other variables\n# -------------------------------------------- #\n#\n# General customer behavior principles (hypotheses) #\n#\n  # people know their own size the best\n  # people know their own sizing system best\n  # some articles of clothing are more difficult to size than others (i.e. pants > t-shirts)\n  # people are generally motivated to save money (price sensitivity)\n    # Some customers are MORE price sensitive\n  # people generally want an item when it is fashionable (fashion sensitivity)\n    # Some customers are MORE fashion sensitive\n  # A purchase outside a customer’s profile is more likely to be returned\n#\n# Tasks #\n#\n# We may consider sorting these later by types of risks \n    # e.g. customer risk, manufacturer risk, price risk, etc.\n#\n# breakout of sizes - done, but may revisit to look at tying to items?\n# mode for all size variables by customer - done\n# number of items per order - done\n# flag for if an item's price drops within x number of days of purchase\n#\n\n#### I'm not entirely sure how to code for these two\n# flag for if customer is price sensitive \n    # may yield other interactions, like increased propensity to return if price drop)\n# flag for if customer is fashion sensitive (may order at earlier dates)\n    # may yield other interactions, like increased propensity to return if product is older or cheaper\n#\n# colorDuplicate = same item ordered on orderDate but in different color as well \n    # instead of doing this, I JUST flagged when the same itemID was ordered more than once\n# orderDuplicate = same exact item ordered >1x on orderDate\n    # see above\n# holidayOrder = orderDate or deliveryDate is within 30 days prior or 5 days post Xmas- done\n# birthdayOrder = order is within 30 days prior or 5 days post customer’s birthday - done\n    # (may have to work a way to make it check bday each year)\n\n# I did the high risk stuff for customer, item, and manufacturer. It could be done for size and color pretty easily, but that didn't make as much sense to me.\n\n# highRiskCustomer = has the customer returned greater than X% of items? \n# (something above the mean return rate)\n# highRiskManufacturer = does this manufacturer get a high % of returns \n    # (may be cleaner than listing out or creating nodes on each manufacturerID)\n# highRiskColor = does this color get returned more frequently \n    # (may be cleaner than listing out or creating nodes on each color)\n# highRiskItem = does this item get returned more frequently \n    # (may be cleaner than listing out or creating nodes on each itemID)\n# Bought on sale?  Or bought at >X% discount?  (each item has a maximum price) \n    # we could see if different price points for each item results in a \n    # different return rate. This would be separate from the subsequent sale returns\n        # I mapped in max and min price for the item but haven't really done anything else with it... do we want to flag if it's the max price, min price, % discount...?\n# UK or US Manufacturer (indicator variable - based on sizing conventions)\n\n",
    "created" : 1399000662356.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2174666747",
    "id" : "D782F045",
    "lastKnownWriteTime" : 1399005433,
    "path" : "~/GitHub/CAPSTONE/Transformations.R",
    "project_path" : "Transformations.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}