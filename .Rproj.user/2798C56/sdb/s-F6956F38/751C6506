{
    "contents" : "# Required libraries\nlibrary(lubridate)\nlibrary(beanplot)\nlibrary(doBy)\nlibrary(modeest)\nlibrary(plyr)\nlibrary(psych)\n\n# We can each add in our working directories here - just un# and # as you check code out and back in\n# setwd(\"C:/Users/Jim Braun/My Documents/Predict 498 Capstone/Data Mining Cup\")\n#\n#\n#\n\n# Read in data from Google Drive\n# Need to update path\n# orders.train <- read.table(\"C:/Users/Katie/Google Drive/Predict 498 Capstone/orders_train.txt\", header = TRUE, sep = \";\")\n# Jim's path\n# orders.train <- read.table(\"C:/Users/Jim Braun/My Documents/Predict 498 Capstone/Data Mining Cup/orders_train.txt\", header = TRUE, sep = \";\")\n7library(tseries)7\nlibrary(forecast)\n\n# Read in data from Google Drive\n# Added the \norders.train <- read.table(\"orders_train.txt\", header = TRUE, sep = \";\")\n#orders.train <- read.table(\"C:/Users/Katie/Google Drive/Predict 498 Capstone/orders_train.txt\", header = TRUE, sep = \";\")\n# orders.train <- read.table(\"C:/Users/Jim Braun/My Documents/Predict 498 Capstone/Data Mining Cup/orders_train.txt\", header = TRUE, sep = \";\")\nstr(orders.train)\n\n# Update date fields to date type instead of factors\norders.train$orderDate <- as.Date(orders.train$orderDate, format = \"%Y-%m-%d\")\norders.train$deliveryDate <- as.Date(orders.train$deliveryDate, format = \"%Y-%m-%d\")\norders.train$dateOfBirth <- as.Date(orders.train$dateOfBirth, format = \"%Y-%m-%d\")\norders.train$creationDate <- as.Date(orders.train$creationDate, format = \"%Y-%m-%d\")\nstr(orders.train)\n\nsummary(orders.train)\n\n# Add date diff variables\norders.train$timeToDeliver <- as.numeric(difftime(orders.train$deliveryDate,orders.train$orderDate,unit=\"days\"))\norders.train$accountAge <- as.numeric(difftime(orders.train$orderDate,orders.train$creationDate,unit=\"weeks\"))/52.25\norders.train$customerAge <- as.numeric(difftime(orders.train$orderDate,orders.train$dateOfBirth,unit=\"weeks\"))/52.25\n\n# Check\nsummary(orders.train[15:17])\n\n# timeToDeliver should never be negative, and age should never be negative\n# call unreal values N/A as if a missing value\n# without access to management, we need to deal with these values another way\n# perhaps through imputation\norders.train$timeToDeliver <- ifelse(orders.train$timeToDeliver<0,NA,orders.train$timeToDeliver)\norders.train$customerAge <- ifelse(orders.train$customerAge<0,NA,orders.train$customerAge)\n# age should also probably not be > 100 - what should we use for the cut-off?\norders.train$customerAge <- ifelse(orders.train$customerAge>100,NA,orders.train$customerAge)\n\n# Recheck\nsummary(orders.train[15:17])\n\n# Look at PDF of numeric variables given reponse\n# Note that we're just using a random sample due to processing time for graphics\nset.seed(498)\nsample_ind <- sample(seq_len(nrow(orders.train)), size = 1000)\norders.sample <- orders.train [sample_ind, ]\n\npdf(file = \"bean_plots.pdf\", width = 11, height = 8.5)  ##/\\open pdf/\\##\nbeanplot(customerAge ~ returnShipment, orders.sample, side = \"b\", col = list(\"yellow\", \"orange\"), border = c(\"yellow2\",\"darkorange\"), main = \"Customer Age Distribution\", ylab = \"Age in Years\", xaxt=\"n\")\nlegend(\"topleft\", bty=\"n\",c(\"Not Returned\", \"Returned\"), fill = c(\"yellow\", \"orange\"))\nbeanplot(accountAge ~ returnShipment, orders.sample, side = \"b\", col = list(\"yellow\", \"orange\"), border = c(\"yellow2\",\"darkorange\"), main = \"Account Age Distribution\", ylab = \"Age in Years\", xaxt=\"n\")\nlegend(\"topleft\", bty=\"n\",c(\"Not Returned\", \"Returned\"), fill = c(\"yellow\", \"orange\"))\nbeanplot(timeToDeliver ~ returnShipment, orders.sample, side = \"b\", col = list(\"yellow\", \"orange\"), border = c(\"yellow2\",\"darkorange\"), main = \"Delivery Time Distribution\", ylab = \"Time in Days\", xaxt=\"n\")\nlegend(\"topleft\", bty=\"n\",c(\"Not Returned\", \"Returned\"), fill = c(\"yellow\", \"orange\"))\nbeanplot(price ~ returnShipment, orders.sample, side = \"b\", col = list(\"yellow\", \"orange\"), border = c(\"yellow2\",\"darkorange\"), main = \"Price Distribution\", xaxt=\"n\")\nlegend(\"topleft\", bty=\"n\",c(\"Not Returned\", \"Returned\"), fill = c(\"yellow\", \"orange\"))\ndev.off()  \t                                          ##\\/close pdf\\/##\n\n# Mean & count of response given nominal vars\n# Only doing ones with few possible values- salutation & state\nsummaryBy(returnShipment ~ salutation, orders.train, FUN=c(length,mean))\nsummaryBy(returnShipment ~ state, orders.train, FUN=c(length,mean))\n\n# More EDA - a breakout of stats by returnShipment\ndescribeBy(orders.train, group=orders.train$returnShipment, mat=FALSE, type=3, digits=6)\n\n# quick X vs Y plot\nplot(orders.sample, cex=0.1)\n\n#--------------------------#\n# DEAL WITH MISSING VALUES #\n#--------------------------#\n\n# using mi package - get visual plot of missing obs\nlibrary(mi)\n# Hmmm, too big to run.  Any ideas guys?\npdf(file = \"missing_obs_plots.pdf\", width = 11, height = 8.5)   ##/\\open pdf/\\##\nmissing.pattern.plot(orders.train, gray.scale = TRUE)\ndev.off()\t\t\t\t\t\t\t\t\t\t                                    ##\\/close pdf\\/##\n\n# One method to check how many observations for each variable have missing values\nsum(is.na(orders.train$orderItemID))\nsum(is.na(orders.train$orderDate))\nsum(is.na(orders.train$deliveryDate))\n# No need to do rest, since this is also covered by summary command\n\n\n#--------------------------#\n#      Imputation???       #\n#--------------------------#\n# need to decide on imputation method: mice?, \nlibrary(mice)\n\n\n#---for future DELETION-------#\n# calculate customer's preferred size\n# this was WAY more complicated than necessary...\n# mvf = most frequent value (a.k.a mode), requires Modeest package and library\n# have to make # obs match orders.sample\n# also, why does this create 3 variables instead of 1?\n# custMode <- summaryBy(size ~ customerID, data=orders.sample, FUN = function (x) {c(m=mfv(x))})\n# custMode\n\n# custMode <- customer\n\n  # sorting orders by customerID to cbind customer Mode to right observation\n#  r <- order(orders.sample$customerID)\n#  r\n#  sortID <- orders.sample[r,]\n#  sortID\n# cbind(sortID,custMode[,2])\n\n# Add column to denote whether the order size was not the customer's usual order (size mode)\n# had to use custMode column instead of one cbinded in. Not sure why, but this works \n# sortID$OrdNotMode <- ifelse((sortID$size != custMode[,2]),0,1)\n# sortID$OrdNotMode\n\n#     beanplot(sortID$OrdNotMode ~ returnShipment, sortID, side = \"b\", col = list(\"yellow\", \"orange\"), border = c(\"yellow2\",\"darkorange\"), main = \"Unusual Size?\", xaxt=\"n\")\n#     legend(\"topleft\", bty=\"n\",c(\"Not Returned\", \"Returned\"), fill = c(\"yellow\", \"orange\"))\n\n# let's try this again...\n#nope\n# mfv(orders.sample$size, group=orders.sample$customerID)\n# mfv(orders.sample$size)\n\n#nope\n# myfun<-function(x){mfv(x)}\n#  summaryBy(orders.sample$size~orders.sample$customerID, data=orders.sample, FUN=myfun)\n\n#nope\n# OB <- orderBy(~orders.sample$customerID+orders.sample$size, data=orders.sample)\n#  OM <- function(d){c(NA,mfv(orders.sample$size)}\n#  v<-lapplyBy(~orders.sample$customerID, data=orders.sample, OM)\n#  orders.sample$OM <-unlist(v)\n\n#-----END DELETION-----#\n\n\n\n# Try this one for modes- but do we need to get a numeric and s/m/l?\n# First convert from a factor to a string, standardizing case\norders.train$revSize <- toupper(as.character(orders.train$size))\n# Add mode function - note that this only gives one mode if there is more than one\nmymode <- function(x){\n  names(sort(-table(as.character(x))))[1]\n}\ncustMode <- summaryBy(revSize ~ customerID, orders.train, FUN=mymode)\n\n# Time-series data - taking the mean of return aggregated by order date\n# NOTE- it's been awhile since I've done a TS analysis, so really I was just looking at the plots & packages here. It will likely need a fair bit of revisions.\navgReturnByDay <- summaryBy(returnShipment ~ orderDate, orders.train, FUN=mean)\nts.orders <- ts(avgReturnByDay$returnShipment.mean, start=c(2012,4), frequency=365)\nplot(ts.orders)\nacf(ts.orders,20)\npacf(ts.orders,20)\nlag.plot(ts.orders,9,do.lines=F)\nplot(diff(ts.orders))\nacf(diff(ts.orders),20)\npacf(diff(ts.orders),20)\nadf.test(ts.orders)\nauto.arima(ts.orders)\n\n\n#list variables for cut and paste within code\n# orderItemID   : int  1 2 3 4 5 6 7 8 9 10 ...\n# orderDate     : Factor w/ 365 levels \"2012-04-01\",\"2012-04-02\",..: 1 1 1 2 2 2 2 2 2 2 ...\n# deliveryDate  : Factor w/ 328 levels \"?\",\"1990-12-31\",..: 3 3 3 1 2 2 2 3 3 3 ...\n# itemID        : int  186 71 71 22 151 598 15 32 32 57 ...\n# size          : Factor w/ 122 levels \"1\",\"10\",\"10+\",..: 110 103 103 110 60 119 60 119 119 119 ...\n# color         : Factor w/ 88 levels \"?\",\"almond\",\"amethyst\",..: 44 70 37 51 19 24 19 24 80 51 ...\n# manufacturerID: int  25 21 21 14 53 87 1 3 3 3 ...\n# price         : num  69.9 70 70 39.9 29.9 ...\n# customerID    : int  794 794 794 808 825 825 825 850 850 850 ...\n# salutation    : Factor w/ 5 levels \"Company\",\"Family\",..: 4 4 4 4 4 4 4 4 4 4 ...\n# dateOfBirth   : Factor w/ 14309 levels \"?\",\"1655-04-19\",..: 7074 7074 7074 5195 6896 6896 6896 1446 1446 1446 ...\n# state         : Factor w/ 16 levels \"Baden-Wuerttemberg\",..: 1 1 1 13 11 11 11 10 10 10 ...\n# creationDate  : Factor w/ 775 levels \"2011-02-16\",\"2011-02-17\",..: 69 69 69 323 1 1 1 1 1 1 ...\n# returnShipment: int  0 1 1 0 0 0 0 1 1 1 ...\n# timeToDeliver \n# accountAge\n# customerAge\n\n#------------#\n# t-tests    #\n#------------#\n# We should add simple t-tests for any binary variables - can use for high risk indicators  \n# independent 2-group t-test\nt.test(y~x) # where y is numeric and x is a binary factor\n\n\n# Plot Histograms for all variables by class\n# will need to sub in our data names #\n# I can't remember what MMST is for, but it was in a lot of my EDA code\nlibrary(MMST)\n\npdf(file = \"hist_plots.pdf\", width = 11, height = 8.5)\nnm <- names(wine)[1:13]\nfor (i in seq(along = nm)) {\n  hist.plot <- ggplot(wine,aes(x = eval(parse(text = paste(\"wine$\", nm[i], sep=\"\"))),\n                               fill=factor(class))) + geom_histogram(alpha = 0.5)+xlab(nm[i])\n  print(hist.plot)\n}\ndev.off()\n\n#-------------------------#\n# Density Plots by class  #\n#-------------------------#\n# includes a loop with output routed to a pdf file\n# will need to sub in our data names #\nlibrary(ggplot2)\npdf(file = \"my_plots.pdf\", width = 11, height = 8.5)\nnm <- names(wine)[1:13]\nfor (i in seq(along = nm)) {\n  this.plot <- ggplot(wine,aes(x = eval(parse(text = paste(\"wine$\", nm[i], sep=\"\"))),\n                               fill=factor(class))) + geom_density(alpha = 0.5)+xlab(nm[i])\n  print(this.plot)\n}\ndev.off()\n\n\n\n#------------------------------------#\n# To illustrate clustering by class  #\n# XY Plot by class                   #\n#------------------------------------#\n# lattice plots for key explanatory variables\n# Shows X&Y relationship by class - Can use for EDA or after algorithm returns top vars\n# But I think this may help identify interaction effects\nlibrary(lattice) # required for the xyplot() function\n\n# this is just a template for integration #\nxyplot(Flav ~ Color | class, \n       data = wine,        \n       layout = c(6, 1),\n       aspect=1,\n       strip=function(...) strip.default(..., style=1),\n       xlab = \"Flavanoids\", \n       ylab = \"Color Intensity\")\n\n# Along same lines, we can look at scatterplots\n# The larger graphs with the overlay \n# make the relationships a bit more visible\nlibrary(car)\n# this is by class\nscatterplot(Flav ~ Color | class, data=wine, boxplots=FALSE, \n            span=0.75, col=gray(c(0,0.5,0.7)),id.n=0)\n\n# this is just X vs. Y.  We can adjust for any specific variable comparisons we want to look at\nscatterplot(carat ~ price, data=diamonds, boxplots=FALSE, \n            span=0.75,id.n=0)\n\n#------------------------------------------#\n# Conditioned XY Plots - to look in panels #\n#------------------------------------------#\n# this was a handy XYplot tool to look at the relationship between 2 variables, conditioned by other variables\n# this was borrowed from our diamonds data set program\n# showing the relationship between price and carat, while conditioning\n# on cut and channel provides a convenient view of the diamonds data\n# in addition, we jitter to show all points in the data frame\nxyplot(jitter(sqrtprice) ~ jitter(carat) | channel + cut, \n       data = diamonds,\n       aspect = 1, \n       layout = c(3, 2),\n       strip=function(...) strip.default(..., style=1),\n       xlab = \"Size or Weight of Diamond (carats)\", \n       ylab = \"Price\")\n\n\n#------------------------------------------------#\n# to run some Weka algorithms - good for EDA too #\n#------------------------------------------------#\nlibrary(RWeka)\n\n# May need to add pruning rules for j48 and JRip #\n\n# to run j48 in RWeka\nreturns_j48 <- J48(class ~., data = orders.train)\nreturns_j48\nsummary(wine_j48)\n\n# to add a 10-folds cross-validation (does it help?)\neval_j48 <- evaluate_Weka_classifier(returns_j48, numFolds = 10, complexity = FALSE, \n                                     seed = 1, class = TRUE)\neval_j48\n\n# To run JRip - Recall this shows rules - will not plot a tree\nreturns_JRip <- JRip(class ~., data = orders.train)\nreturns_JRip\nsummary(returns_JRip)\n",
    "created" : 1397943344845.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2954790194",
    "id" : "751C6506",
    "lastKnownWriteTime" : 1397947975,
    "path" : "~/GitHub/CAPSTONE/DMC_KT.r",
    "project_path" : "DMC_KT.r",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}