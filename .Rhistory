orders.sample <- orders.train [sample_ind, ]
beanplot(customerAge ~ returnShipment, orders.sample, side = "b", col = list("yellow", "orange"), border = c("yellow2","darkorange"), main = "Customer Age Distribution", ylab = "Age in Years", xaxt="n")
legend("topleft", bty="n",c("Not Returned", "Returned"), fill = c("yellow", "orange"))
beanplot(accountAge ~ returnShipment, orders.sample, side = "b", col = list("yellow", "orange"), border = c("yellow2","darkorange"), main = "Account Age Distribution", ylab = "Age in Years", xaxt="n")
legend("topleft", bty="n",c("Not Returned", "Returned"), fill = c("yellow", "orange"))
beanplot(timeToDeliver ~ returnShipment, orders.sample, side = "b", col = list("yellow", "orange"), border = c("yellow2","darkorange"), main = "Delivery Time Distribution", ylab = "Time in Days", xaxt="n")
legend("topleft", bty="n",c("Not Returned", "Returned"), fill = c("yellow", "orange"))
beanplot(price ~ returnShipment, orders.sample, side = "b", col = list("yellow", "orange"), border = c("yellow2","darkorange"), main = "Price Distribution", xaxt="n")
legend("topleft", bty="n",c("Not Returned", "Returned"), fill = c("yellow", "orange"))
plot(orders.sample, cex=0.1)
custSize <- with(orders.sample, tapply(size, customerID, max(table(size)))
)
custSize <- with(orders.sample, tapply(size, customerID, max)))
custSize <- with(orders.sample, tapply(size, customerID, max))
custSize <- xtabs(~customerID + size, data=orders.sample)
custSize
table(customerID,size)
customerID
table(customerID,size, data=orders.sample)
names(order.sample)
names(orders.sample)
custSize <- rbind(customerID,size)
custSize <- rbind(customerID,size, data=orders.sample)
customerID
price
custSize <- xtabs(~customerID + size, data=orders.sample)
> custSize
custsize
custSize
custID <- c(customerID)
sapply(orders.sample, mode, na.rm=TRUE)
sapply(orders.sample, mode)
orders.train <- read.table("C:/Users/Katie/Google Drive/Predict 498 Capstone/orders_train.txt", header = TRUE, sep = ";")
# Jim's path
# orders.train <- read.table("C:/Users/Jim Braun/My Documents/Predict 498 Capstone/Data Mining Cup/orders_train.txt", header = TRUE, sep = ";")
str(orders.train)
# Update date fields to date type instead of factors
orders.train$orderDate <- as.Date(orders.train$orderDate, format = "%Y-%m-%d")
orders.train$deliveryDate <- as.Date(orders.train$deliveryDate, format = "%Y-%m-%d")
orders.train$dateOfBirth <- as.Date(orders.train$dateOfBirth, format = "%Y-%m-%d")
orders.train$creationDate <- as.Date(orders.train$creationDate, format = "%Y-%m-%d")
str(orders.train)
summary(orders.train)
# Add date diff variables
orders.train$timeToDeliver <- as.numeric(difftime(orders.train$deliveryDate,orders.train$orderDate,unit="days"))
orders.train$accountAge <- as.numeric(difftime(orders.train$orderDate,orders.train$creationDate,unit="weeks"))/52.25
orders.train$customerAge <- as.numeric(difftime(orders.train$orderDate,orders.train$dateOfBirth,unit="weeks"))/52.25
# Check
summary(orders.train[15:17])
# timeToDeliver should never be negative, and age should never be negative
orders.train$timeToDeliver <- ifelse(orders.train$timeToDeliver<0,NA,orders.train$timeToDeliver)
orders.train$customerAge <- ifelse(orders.train$customerAge<0,NA,orders.train$customerAge)
# age should also probably not be > 100 - what should we use for the cut-off?
orders.train$customerAge <- ifelse(orders.train$customerAge>100,NA,orders.train$customerAge)
# Recheck
summary(orders.train[15:17])
# Look at PDF of numeric variables given reponse
# Note that we're just using a random sample due to processing time for graphics
set.seed(498)
sample_ind <- sample(seq_len(nrow(orders.train)), size = 100)
orders.sample <- orders.train [sample_ind, ]
beanplot(customerAge ~ returnShipment, orders.sample, side = "b", col = list("yellow", "orange"), border = c("yellow2","darkorange"), main = "Customer Age Distribution", ylab = "Age in Years", xaxt="n")
legend("topleft", bty="n",c("Not Returned", "Returned"), fill = c("yellow", "orange"))
beanplot(accountAge ~ returnShipment, orders.sample, side = "b", col = list("yellow", "orange"), border = c("yellow2","darkorange"), main = "Account Age Distribution", ylab = "Age in Years", xaxt="n")
legend("topleft", bty="n",c("Not Returned", "Returned"), fill = c("yellow", "orange"))
beanplot(timeToDeliver ~ returnShipment, orders.sample, side = "b", col = list("yellow", "orange"), border = c("yellow2","darkorange"), main = "Delivery Time Distribution", ylab = "Time in Days", xaxt="n")
legend("topleft", bty="n",c("Not Returned", "Returned"), fill = c("yellow", "orange"))
beanplot(price ~ returnShipment, orders.sample, side = "b", col = list("yellow", "orange"), border = c("yellow2","darkorange"), main = "Price Distribution", xaxt="n")
legend("topleft", bty="n",c("Not Returned", "Returned"), fill = c("yellow", "orange"))
# Mean & count of response given nominal vars
# Only doing ones with few possible values- salutation & state
summaryBy(returnShipment ~ salutation, orders.train, FUN=c(length,mean))
summaryBy(returnShipment ~ state, orders.train, FUN=c(length,mean))
names(orders.sample)
summaryBy(customerID ~ size, data=orders.sample, FUN = function (x) {c(m=mad(x))})
summaryBy(size ~ customerID, data=orders.sample, FUN = function (x) {c(m=mad(x))})
summaryBy(size ~ customerID, data=orders.sample, FUN = function (x) {c(m=max(x))})
summaryBy(size ~ customerID, data=orders.sample, FUN = function (x) {c(m=mode(x))})
summaryBy(size ~ customerID, data=orders.sample, FUN = function (x) {c(m=mfv(x))})
library(modeest)
install.packages("modeest")
library(modeest)
summaryBy(size ~ customerID, data=orders.sample, FUN = function (x) {c(m=mfv(x))})
custMode <- summaryBy(size ~ customerID, data=orders.sample, FUN = function (x) {c(m=mfv(x))})
custMode
orders.sample$OrdNotMode <- ifelse((size != custMode),0,1)
orders.sample$OrdNotMode
orders.sample$OrdNotMode <- ifelse((orders.sample$size != orders.sample$custMode),0,1)
orders.sample$OrdNotMode
cbind(orders.sample,custMode)
orders.sample[-18]
order(orders.sample$customerID)
r <- order(orders.sample$customerID)
r
sortID <- orders.sample[r,]
sortID
cbind(sortID,custMode[,2])
orders.sample$OrdNotMode <- ifelse((orders.sample$size != orders.sample$custMode),0,1)
orders.sample$OrdNotMode
sortID$OrdNotMode <- ifelse((size != custMode),0,1)
sortID
sortID$OrdNotMode <- ifelse((sortID$size != sortID$custMode),0,1)
sortID$OrdNotMode <- ifelse((sortID$size != custMode[,2]),0,1)
sortID
set.seed(498)
sample_ind <- sample(seq_len(nrow(orders.train)), size = 10000)
orders.sample <- orders.train [sample_ind, ]
beanplot(customerAge ~ returnShipment, orders.sample, side = "b", col = list("yellow", "orange"), border = c("yellow2","darkorange"), main = "Customer Age Distribution", ylab = "Age in Years", xaxt="n")
legend("topleft", bty="n",c("Not Returned", "Returned"), fill = c("yellow", "orange"))
beanplot(accountAge ~ returnShipment, orders.sample, side = "b", col = list("yellow", "orange"), border = c("yellow2","darkorange"), main = "Account Age Distribution", ylab = "Age in Years", xaxt="n")
legend("topleft", bty="n",c("Not Returned", "Returned"), fill = c("yellow", "orange"))
beanplot(timeToDeliver ~ returnShipment, orders.sample, side = "b", col = list("yellow", "orange"), border = c("yellow2","darkorange"), main = "Delivery Time Distribution", ylab = "Time in Days", xaxt="n")
legend("topleft", bty="n",c("Not Returned", "Returned"), fill = c("yellow", "orange"))
beanplot(price ~ returnShipment, orders.sample, side = "b", col = list("yellow", "orange"), border = c("yellow2","darkorange"), main = "Price Distribution", xaxt="n")
legend("topleft", bty="n",c("Not Returned", "Returned"), fill = c("yellow", "orange"))
# Mean & count of response given nominal vars
# Only doing ones with few possible values- salutation & state
summaryBy(returnShipment ~ salutation, orders.train, FUN=c(length,mean))
summaryBy(returnShipment ~ state, orders.train, FUN=c(length,mean))
names(orders.sample)
# quick X vs Y plot
#plot(orders.sample, cex=0.1)
# calculate customer's preferred size
# this was WAY more complicated than necessary...
# mvf = most frequent value (a.k.a mode), requires Modeest package and library
custMode <- summaryBy(size ~ customerID, data=orders.sample, FUN = function (x) {c(m=mfv(x))})
custMode
# sorting orders by customerID to cbind customer Mode to right observation
r <- order(orders.sample$customerID)
r
sortID <- orders.sample[r,]
sortID
cbind(sortID,custMode[,2])
# Add column to denote whether the order size was not the customer's usual order (size mode)
# had to use custMode column instead of one cbinded in. Not sure why, but this works
sortID$OrdNotMode <- ifelse((sortID$size != custMode[,2]),0,1)
sortID
set.seed(498)
sample_ind <- sample(seq_len(nrow(orders.train)), size = 100000)
orders.sample <- orders.train [sample_ind, ]
custMode <- summaryBy(size ~ customerID, data=orders.sample, FUN = function (x) {c(m=mfv(x))})
custMode
# sorting orders by customerID to cbind customer Mode to right observation
r <- order(orders.sample$customerID)
r
sortID <- orders.sample[r,]
sortID
cbind(sortID,custMode[,2])
# Add column to denote whether the order size was not the customer's usual order (size mode)
# had to use custMode column instead of one cbinded in. Not sure why, but this works
sortID$OrdNotMode <- ifelse((sortID$size != custMode[,2]),0,1)
sortID
sortID$OrdNotMode
beanplot(OrdNotMode ~ returnShipment, orders.sample, side = "b", col = list("yellow", "orange"), border = c("yellow2","darkorange"), main = "Unusual Size?", xaxt="n")
legend("topleft", bty="n",c("Not Returned", "Returned"), fill = c("yellow", "orange"))
beanplot(sortID$OrdNotMode ~ returnShipment, sortID, side = "b", col = list("yellow", "orange"), border = c("yellow2","darkorange"), main = "Unusual Size?", xaxt="n")
legend("topleft", bty="n",c("Not Returned", "Returned"), fill = c("yellow", "orange"))
set.seed(498)
sample_ind <- sample(seq_len(nrow(orders.train)), size = 5000)
orders.sample <- orders.train [sample_ind, ]
custMode <- summaryBy(size ~ customerID, data=orders.sample, FUN = function (x) {c(m=mfv(x))})
custMode
# sorting orders by customerID to cbind customer Mode to right observation
r <- order(orders.sample$customerID)
r
sortID <- orders.sample[r,]
sortID
cbind(sortID,custMode[,2])
# Add column to denote whether the order size was not the customer's usual order (size mode)
# had to use custMode column instead of one cbinded in. Not sure why, but this works
sortID$OrdNotMode <- ifelse((sortID$size != custMode[,2]),0,1)
sortID$OrdNotMode
beanplot(sortID$OrdNotMode ~ returnShipment, sortID, side = "b", col = list("yellow", "orange"), border = c("yellow2","darkorange"), main = "Unusual Size?", xaxt="n")
legend("topleft", bty="n",c("Not Returned", "Returned"), fill = c("yellow", "orange"))
orders.train <- read.table("C:/Users/Katie/Google Drive/Predict 498 Capstone/orders_train.txt", header = TRUE, sep = ";")
orders.train <- read.table("C:/Users/Jim Braun/My Documents/Predict 498 Capstone/Data Mining Cup/orders_train.txt", header = TRUE, sep = ";")
# Update date fields to date type instead of factors
orders.train$orderDate <- as.Date(orders.train$orderDate, format = "%Y-%m-%d")
orders.train$deliveryDate <- as.Date(orders.train$deliveryDate, format = "%Y-%m-%d")
orders.train$dateOfBirth <- as.Date(orders.train$dateOfBirth, format = "%Y-%m-%d")
orders.train$creationDate <- as.Date(orders.train$creationDate, format = "%Y-%m-%d")
str(orders.train)
summary(orders.train)
# Add date diff variables
orders.train$timeToDeliver <- as.numeric(difftime(orders.train$deliveryDate,orders.train$orderDate,unit="days"))
orders.train$accountAge <- as.numeric(difftime(orders.train$orderDate,orders.train$creationDate,unit="weeks"))/52.25
orders.train$customerAge <- as.numeric(difftime(orders.train$orderDate,orders.train$dateOfBirth,unit="weeks"))/52.25
# Check
summary(orders.train[15:17])
# timeToDeliver should never be negative, and age should never be negative
orders.train$timeToDeliver <- ifelse(orders.train$timeToDeliver<0,NA,orders.train$timeToDeliver)
orders.train$customerAge <- ifelse(orders.train$customerAge<0,NA,orders.train$customerAge)
# age should also probably not be > 100 - what should we use for the cut-off?
orders.train$customerAge <- ifelse(orders.train$customerAge>100,NA,orders.train$customerAge)
# Recheck
summary(orders.train[15:17])
set.seed(498)
sample_ind <- sample(seq_len(nrow(orders.train)), size = 5000)
orders.sample <- orders.train [sample_ind, ]
custMode <- summaryBy(size ~ customerID, data=orders.sample, FUN = function (x) {c(m=mfv(x))})
custMode
custMode <- summaryBy(size ~ customerID, data=orders.sample, FUN = function (x) {c(m=mfv(x))})
custMode
custMode2 <- summaryBy(customerID ~ size, data=orders.sample, FUN = function (x) {c(m=mfv(x))})
custMode2
max(customerID)
max(orders.sample$customerID)
numObs <- count(orders.sample$customerID)
numObs <- table(orders.sample$customerID)
numObs
tabulate(orders.sample$customerID)
library(plyr)
numObs <- count(orders.sample$customerID)
numObs
set.seed(498)
sample_ind <- sample(seq_len(nrow(orders.train)), size = 1000)
orders.sample <- orders.train [sample_ind, ]
custMode <- summaryBy(size ~ customerID, data=orders.sample, FUN = function (x) {c(m=mfv(x))})
custMode
install.packages("psych")
library(psych)
describe.by(orders.sample, customerID, size)
describe.by(orders.sample, size, customerID)
describeBy(orders.sample, size, customerID)
describeBy(orders.sample, customerID, size)
describeBy(custMode, customerID, size)
describeBy(custMode, group=customerID, mat=FALSE, type=3, digits=3)
describeBy(orders.Sample, group=returnShipment, mat=FALSE, type=3, digits=6)
describeBy(orders.sample, group=returnShipment, mat=FALSE, type=3, digits=6)
describeBy(orders.sample, group=orders.sample$returnShipment, mat=FALSE, type=3, digits=6)
mfv(size, group=customerID)
mfv(orders.sample$size, group=orders.sample$customerID)
mfv(orders.sample$size)
myfun<-function(x){mvf(x)}
summaryBy(orders.sample$size~orders.sample$customerID, data=orders.sample, FUN=myfun)
myfun<-function(x){mfv(x)}
summaryBy(orders.sample$size~orders.sample$customerID, data=orders.sample, FUN=myfun)
OB<-orderBy(~orders.sample$customerID+orders.sample$size, data=orders.sample)
OM <- function(d){c(NA,mfvorders.sample$size)}
v<-lapplyBy(~orders.sample$customerID, data=orders.sample, OM)
orders.sample$OM <-unlist(v)
data(orders.sample)
OB <- orderBy(~orders.sample$customerID+orders.sample$size, data=orders.sample)
OM <- function(d){c(NA,mfvorders.sample$size)}
v<-lapplyBy(~orders.sample$customerID, data=orders.sample, OM)
orders.sample$OM <-unlist(v)
OB <- orderBy(~orders.sample$customerID+orders.sample$size, data=orders.sample)
OM <- function(d){c(NA,mfv(orders.sample$size)}
v<-lapplyBy(~orders.sample$customerID, data=orders.sample, OM)
orders.sample$OM <-unlist(v)
library(beanplot)
library(doBy)
library(psych)
library(mi)
library(tseries)
library(forecast)
library(MMST)
library(ggplot2)
library(lattice) # required for the xyplot() function
library(car)
library(RWeka)
smp_size <- floor(0.7 * max(orders.train$orderID))
set.seed(498)
train_ind <- sample(seq_len(max(orders.train$orderID)), size = smp_size)
orders.train$trainTest <- train_ind[orders.train$orderID]
train <- orders.train[which(orders.train$trainTest>0), ]
test <- orders.train[-which(orders.train$trainTest>0), ]
remove(smp_size,train_ind)
# Read in data from GitHub
orders.train <- read.table("orders_train.txt", header = TRUE, sep = ";")
str(orders.train)
# Update date fields to date type instead of factors
orders.train$orderDate <- as.Date(orders.train$orderDate, format = "%Y-%m-%d")
orders.train$deliveryDate <- as.Date(orders.train$deliveryDate, format = "%Y-%m-%d")
orders.train$dateOfBirth <- as.Date(orders.train$dateOfBirth, format = "%Y-%m-%d")
orders.train$creationDate <- as.Date(orders.train$creationDate, format = "%Y-%m-%d")
# Add date diff variables
# Time from when order was placed to delivery, in days
orders.train$timeToDeliver <- as.numeric(difftime(orders.train$deliveryDate,orders.train$orderDate,unit="days"))
# Age of the account, in years but rounded to nearest tenth- seemed like a continuous variable was overkill here
orders.train$accountAge <- round(as.numeric(difftime(orders.train$orderDate,orders.train$creationDate,unit="weeks"))/52.25,1)
# want customer's age as an integer, similar to when you ask how old someone is
orders.train$customerAge <- floor(as.numeric(difftime(orders.train$orderDate,orders.train$dateOfBirth,unit="weeks"))/52.25)
# Check
summary(orders.train[15:17])
# timeToDeliver should never be negative, and age should never be negative
orders.train$timeToDeliver <- ifelse(orders.train$timeToDeliver<0,NA,orders.train$timeToDeliver)
orders.train$customerAge <- ifelse(orders.train$customerAge<0,NA,orders.train$customerAge)
# age should also probably not be > 100 - what should we use for the cut-off?
orders.train$customerAge <- ifelse(orders.train$customerAge>100,NA,orders.train$customerAge)
# Recheck
summary(orders.train[15:17])
# Sizing recodes - creating a table with frequencies to work from and going to remove sizes as I recode them
# There may be some errors here- for example, Euro children's sizes start at 50, but some conversions go up to size 52 for men's suits, etc
size.table <- summaryBy(size ~ size,orders.train,FUN=length)
View(size.table)
# Ones that seem like US sizes
orders.train$sizeLetter <- ifelse(as.character(orders.train$size)>"a",toupper(as.character(orders.train$size)),NA)
size.table <- size.table[-which(as.character(size.table$size)>"a"),]
orders.train$sizePant <- ifelse(as.numeric(as.character(orders.train$size))>2900,as.numeric(as.character(orders.train$size)),NA)
size.table <- size.table[-which(as.numeric(as.character(size.table$size))>2900),]
# Euro children's sizes go from 50-188
# http://www.ebay.com/gds/Guide-to-Understanding-European-Clothing-Sizes-/10000000007740616/g.html
orders.train$sizeChild <- ifelse(as.numeric(as.character(orders.train$size))>=50 & as.numeric(as.character(orders.train$size))<=188,as.numeric(as.character(orders.train$size)),NA)
size.table <- size.table[-which(as.numeric(as.character(size.table$size))>=50 & as.numeric(as.character(size.table$size))<=188),]
# Remaining
orders.train$sizeOther <- ifelse(is.na(orders.train$sizeLetter) & is.na(orders.train$sizePant) & is.na(orders.train$sizeChild),as.character(orders.train$size),NA)
# Add mode function - note that this only gives one mode if there is more than one
mymode <- function(x){
names(sort(-table(as.character(x))))[1]
}
custMode1 <- summaryBy(toupper(as.character(orders.train$size)) ~ orders.train$customerID, orders.train, FUN=mymode)
custMode2 <- summaryBy(sizeLetter ~ customerID, orders.train[-which(is.na(orders.train$sizeLetter)),], FUN=mymode)
custMode3 <- summaryBy(sizePant ~ customerID, orders.train[-which(is.na(orders.train$sizePant)),], FUN=mymode)
custMode4 <- summaryBy(sizeChild ~ customerID, orders.train[-which(is.na(orders.train$sizeChild)),], FUN=mymode)
custMode5 <- summaryBy(sizeOther ~ customerID, orders.train[-which(is.na(orders.train$sizeOther)),], FUN=mymode)
custMode <- merge(custMode1,custMode2,by="customerID",all=T)
custMode <- merge(custMode,custMode3,by="customerID",all=T)
custMode <- merge(custMode,custMode4,by="customerID",all=T)
custMode <- merge(custMode,custMode5,by="customerID",all=T)
names(custMode) <- c("customerID","sizeMode","szLetterMode","szPantMode", "szChildMode", "szOtherMode")
# Merge back into original file, then drop the unnecessary data frames to clean up the workspace
orders.train <- merge(orders.train,custMode,by="customerID",all=T)
remove(custMode,custMode1,custMode2,custMode3,custMode4,custMode5,size.table)
# Add holiday/bday flags
orders.train$holidayFlag <- ifelse(as.character(orders.train$orderDate,format="%m%d")>="1125" &
as.character(orders.train$orderDate,format="%m%d")<="1230",1,0)
orders.train$bdayFlag <- ifelse(as.character(orders.train$orderDate,format="%m%d")>=as.character(orders.train$dateOfBirth-30,format="%m%d") &
as.character(orders.train$orderDate,format="%m%d")<=as.character(orders.train$dateOfBirth+5,format="%m%d"),1,0)
summaryBy(bdayFlag ~ 1, orders.train, FUN=sum, na.rm=T)
# Bdays after 12/26 or before 1/31 - the order date can be until the end of the year and part of the next
orders.train$bdayFlag <- ifelse((as.character(orders.train$dateOfBirth,format="%m%d")>"1226"|as.character(orders.train$dateOfBirth,format="%m%d")<="0130") &
(as.character(orders.train$orderDate,format="%m%d")>=as.character(orders.train$dateOfBirth-30,format="%m%d") | as.numeric(as.character(orders.train$orderDate,format="%m%d"))<=as.numeric(as.character(orders.train$dateOfBirth+5,format="%m%d"))),1,orders.train$bdayFlag)
summaryBy(bdayFlag ~ 1, orders.train, FUN=sum, na.rm=T)
# Visually check some of these - appears to be working correctly
View(orders.train[which(orders.train$bdayFlag==1 & (as.character(orders.train$orderDate,format="%m%d")<"0104" | as.character(orders.train$orderDate,format="%m%d")>"1215")),])
# Add number of items per order
numItems <- summaryBy(orderItemID ~ customerID + orderDate, orders.train, FUN=length)
names(numItems) <- c("customerID","orderDate","numItemsInOrder")
orders.train <- merge(orders.train,numItems,by=c("customerID","orderDate"))
# Add num items with that items ID per order
# Also looking at number of returns since we expect higher returns if they order dups
dupItems <- summaryBy(returnShipment ~ customerID + orderDate + itemID, orders.train, FUN=c(length,sum))
names(dupItems) <- c("customerID","orderDate","itemID","numItemID","numItemIDReturned")
# Check hypothesis
summaryBy(numItemIDReturned ~ numItemID, dupItems, FUN=c(length,median,mean))
# Leaving out number returned when merging back in because we don't want to accidentally include as a predictor
orders.train <- merge(orders.train,dupItems[1:4],by=c("customerID","orderDate","itemID"))
# Dropping unnecessary data frames
remove(numItems,dupItems)
riskyManuf <- summaryBy(returnShipment ~ manufacturerID,orders.train,FUN=c(length,mean))
summary(riskyManuf$returnShipment.mean)
summary(riskyManuf$returnShipment.length)
summary(riskyManuf[which(riskyManuf$returnShipment.length>=50),]$returnShipment.mean)
# Using top quartile for a risk cutoff
riskyManuf$manufRiskFlag <- ifelse(riskyManuf$returnShipment.length>=50 & riskyManuf$returnShipment.mean >=0.5573,1,0)
names(riskyManuf) <- c("manufacturerID","numManufOrders","numManufReturns","manufRiskFlag")
# Merge
orders.train <- merge(orders.train,riskyManuf,by="manufacturerID")
riskyItems <- summaryBy(returnShipment ~ itemID,orders.train,FUN=c(length,mean))
summary(riskyItems$returnShipment.mean)
summary(riskyItems$returnShipment.length)
summary(riskyItems[which(riskyItems$returnShipment.length>=50),]$returnShipment.mean)
# Using top quartile for a risk cutoff
riskyItems$itemRiskFlag <- ifelse(riskyItems$returnShipment.length>=50 & riskyItems$returnShipment.mean >=0.5938,1,0)
names(riskyItems) <- c("itemID","numItemOrders","numItemReturns","itemRiskFlag")
# Merge
orders.train <- merge(orders.train,riskyItems,by="itemID")
# Customers
riskyCust <- summaryBy(returnShipment ~ customerID,orders.train,FUN=c(length,mean))
summary(riskyCust$returnShipment.mean)
summary(riskyCust$returnShipment.length)
summary(riskyCust[which(riskyCust$returnShipment.length>=50),]$returnShipment.mean)
# Using top quartile for a risk cutoff
riskyCust$custRiskFlag <- ifelse(riskyCust$returnShipment.length>=50 & riskyCust$returnShipment.mean >=0.6667,1,0)
names(riskyCust) <- c("customerID","numCustOrders","numCustReturns","custRiskFlag")
# Merge & clear workspace
orders.train <- merge(orders.train,riskyCust,by="customerID")
remove(riskyManuf,riskyItems,riskyCust)
itemPricing <- merge(summaryBy(price ~ itemID,orders.train,FUN=quantile),
summaryBy(price ~ itemID,orders.train,FUN=mean),by="itemID")
View(itemPricing) # confirmed, going to attach to the orders.train data frame so we can later flag
orders.train <- merge(orders.train, itemPricing, by="itemID")
remove(itemPricing)
# Look at mean of returnShipment for each price point
# Currently saving this out as a separate table because I'm not entirely sure what to do with it
returnsByPrice <- summaryBy(returnShipment ~ itemID + price, orders.train, FUN=c(length,mean))
orders.table <- summaryBy(returnShipment ~ orderDate + customerID, orders.train, FUN=mean)
orders.table$orderID <- 1:nrow(orders.table)
orders.table <- orders.table[,-3]
orders.train <- merge(orders.train,orders.table,by=c("customerID","orderDate"))
remove(orders.table)
str(orders.train)
returns_j48 <- J48(returnShipment ~., data = orders.train)
returns_j48
summary(returns_j48)
returns_j48 <- J48(returnShipment ~ color + salutation + timeToDeliver + accountAge
+ state + customerAge + holidayFlag + bdayFlag + numItemsInOrder
+ manuRiskFlag + itemRiskFlag
, data = orders.train)
returns_j48
summary(returns_j48)
returns_j48 <- J48(returnShipment ~ color + salutation + timeToDeliver + accountAge
+ state + customerAge + holidayFlag + bdayFlag + numItemsInOrder
+ manufRiskFlag + itemRiskFlag
, data = orders.train)
returns_j48 <- J48(returnShipment ~ color + timeToDeliver + accountAge
+ state + customerAge + holidayFlag + bdayFlag + numItemsInOrder
+ manufRiskFlag + itemRiskFlag
, data = orders.train)
+ customerAge + holidayFlag + bdayFlag + numItemsInOrder
returns_j48 <- J48(returnShipment ~ color + timeToDeliver + accountAge
+ customerAge + holidayFlag + bdayFlag + numItemsInOrder
+ manufRiskFlag + itemRiskFlag
, data = orders.train)
library(randomForest)
fit <- randomForest(returnShipment ~ color + timeToDeliver + accountAge
+ customerAge + holidayFlag + bdayFlag + numItemsInOrder
+ manufRiskFlag + itemRiskFlag
, data = orders.train)
summary(returnShipment)
str(returnShipment)
summary(orders.train)
returns.lr <- glm(returnShipment ~ color + timeToDeliver + accountAge
+ customerAge + holidayFlag + bdayFlag + numItemsInOrder
+ manufRiskFlag + itemRiskFlag,
family=binomial(link=logit), data=orders.train)
summary(returns.lr)
library(doBy)
library(ggplot2)
# Read in data from GitHub
orders.train <- read.table("orders_train.txt", header = TRUE, sep = ";")
str(orders.train)
# Update date fields to date type instead of factors
orders.train$orderDate <- as.Date(orders.train$orderDate, format = "%Y-%m-%d")
orders.train$deliveryDate <- as.Date(orders.train$deliveryDate, format = "%Y-%m-%d")
orders.train$dateOfBirth <- as.Date(orders.train$dateOfBirth, format = "%Y-%m-%d")
orders.train$creationDate <- as.Date(orders.train$creationDate, format = "%Y-%m-%d")
# Summary data for the QA report
summary(orders.train$orderDate)
summary(orders.train$deliveryDate)
summary(orders.train$creationDate)
summary(orders.train$dateOfBirth)
# Export top and bottom 10 cases for QA report
print(orders.train[1:10,])
print(orders.train[481083:481092,])
table(orders.train$size)
table(orders.train$color)
table(orders.train$salutation)
table(orders.train$state)
table(orders.train$returnShipment)
# Need to update options to fit labels
par(las=2) # make label text perpendicular to axis
options(scipen=50,digits=5) # change default setting for when R converts to using sci notation
barplot(table(orders.train$size), main="Size Distribution", horiz=TRUE, cex.names=0.5)
par(mar=c(4,6,4,2)) # increase y-axis margin (order is bottom,left,top,right)
barplot(table(orders.train$color), main="Color Distribution", horiz=TRUE, cex.names=0.6)
barplot(table(orders.train$salutation), main="Salutation Distribution", horiz=TRUE)
par(mar=c(4,10,4,2)) # increase y-axis margin (order is bottom,left,top,right)
barplot(table(orders.train$state), main="State Distribution", horiz=TRUE, cex.names=0.6)
orders.train[-which(orders.train$orderItemID!=orders.train$row.names),]
item.check <- summaryBy(manufacturerID ~ itemID, orders.train, FUN=c(min,max))
item.check[-which(item.check$manufacturerID.min==item.check$manufacturerID.max),]
View(orders.train[which(orders.train$itemID==c(1627,1682,1696,2252)),])
View(orders.train[which(orders.train$itemID==c(1627)),])
View(orders.train[which(orders.train$itemID==c(1627)),])
View(orders.train[which(orders.train$itemID==c(1682)),])
View(orders.train[which(orders.train$itemID==c(1696)),])
cust.check <- summaryBy(salutation + state + dateOfBirth + creationDate ~ customerID, orders.train, FUN=c(min,max))
View(orders.train[which(orders.train$itemID==c(1627,1682,1696,2252)),])
cust.check[-which(cust.check$salutation.min==cust.check$salutation.max),] # 0 records
cust.check[-which(cust.check$state.min==cust.check$state.max),] # 0 records
cust.check[-which(cust.check$dateOfBirth.min==cust.check$dateOfBirth.max),] # large number of records, viewing the table instead
View(cust.check[-which(cust.check$dateOfBirth.min==cust.check$dateOfBirth.max),]) # looks like they're all NAs, which are ok
cust.check[-which(cust.check$creationDate.min==cust.check$creationDate.max),] # 0 records
cust.check <- summaryBy(salutation + state + dateOfBirth + creationDate ~ customerID, orders.train, FUN=c(min,max))
View(cust.check)
remove(cust.check)
orders.train$timeToDeliver <- as.numeric(difftime(orders.train$deliveryDate,orders.train$orderDate,unit="days"))
# Age of the account, in years but rounded to nearest tenth- seemed like a continuous variable was overkill here
orders.train$accountAge <- round(as.numeric(difftime(orders.train$orderDate,orders.train$creationDate,unit="weeks"))/52.25,1)
# want customer's age as an integer, similar to when you ask how old someone is
orders.train$customerAge <- floor(as.numeric(difftime(orders.train$orderDate,orders.train$dateOfBirth,unit="weeks"))/52.25)
# Check
summary(orders.train[15:17])
# timeToDeliver should never be negative, and age should never be negative
orders.train$timeToDeliver <- ifelse(orders.train$timeToDeliver<0,NA,orders.train$timeToDeliver)
orders.train$customerAge <- ifelse(orders.train$customerAge<0,NA,orders.train$customerAge)
# age should also probably not be > 100 - what should we use for the cut-off?
orders.train$customerAge <- ifelse(orders.train$customerAge>100,NA,orders.train$customerAge)
# Recheck
summary(orders.train[15:17])
orders.train$color <- ifelse(orders.train$color=="?",NA,orders.train$color)
# Recode "not reported" to NA for salutation
orders.train$salutation <- ifelse(orders.train$salutation=="not reported",NA,orders.train$salutation)
size.table <- summaryBy(size ~ size,orders.train,FUN=length)
View(size.table)
orders.train$sizeLetter <- ifelse(as.character(orders.train$size)>"a",toupper(as.character(orders.train$size)),NA)
size.table <- size.table[-which(as.character(size.table$size)>"a"),]
orders.train$sizePant <- ifelse(as.numeric(as.character(orders.train$size))>2900,as.numeric(as.character(orders.train$size)),NA)
size.table <- size.table[-which(as.numeric(as.character(size.table$size))>2900),]
# Euro children's sizes go from 50-188
# http://www.ebay.com/gds/Guide-to-Understanding-European-Clothing-Sizes-/10000000007740616/g.html
orders.train$sizeChild <- ifelse(as.numeric(as.character(orders.train$size))>=50 & as.numeric(as.character(orders.train$size))<=188,as.numeric(as.character(orders.train$size)),NA)
size.table <- size.table[-which(as.numeric(as.character(size.table$size))>=50 & as.numeric(as.character(size.table$size))<=188),]
# Remaining
orders.train$sizeOther <- ifelse(is.na(orders.train$sizeLetter) & is.na(orders.train$sizePant) & is.na(orders.train$sizeChild),as.character(orders.train$size),NA)
# check
table(orders.train$sizeLetter)
table(orders.train$sizePant)
table(orders.train$sizeChild)
table(orders.train$sizeOther)
